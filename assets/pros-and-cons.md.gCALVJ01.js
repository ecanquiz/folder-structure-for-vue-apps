import{_ as a,c as o,o as n,ae as r}from"./chunks/framework.oSdz25v6.js";const m=JSON.parse('{"title":"Pros y Contras","description":"","frontmatter":{},"headers":[],"relativePath":"pros-and-cons.md","filePath":"pros-and-cons.md"}'),s={name:"pros-and-cons.md"};function l(t,e,i,c,d,u){return n(),o("div",null,e[0]||(e[0]=[r('<p>Por: <a href="https://github.com/ecanquiz" target="_blank" rel="noreferrer">Ernesto Canquiz</a></p><h1 id="pros-y-contras" tabindex="-1">Pros y Contras <a class="header-anchor" href="#pros-y-contras" aria-label="Permalink to &quot;Pros y Contras&quot;">​</a></h1><blockquote><p>Echemos un vistazo más de cerca a los pros y contras de la estructura modular anidada de componentes y componibles.</p></blockquote><h2 id="pros" tabindex="-1">Pros <a class="header-anchor" href="#pros" aria-label="Permalink to &quot;Pros&quot;">​</a></h2><ul><li><strong>Agrupación de Archivos Relacionados</strong>: Los archivos que están estrechamente relacionados quedan todos juntos en la misma carpeta.</li></ul><blockquote><p>Esto reduce la necesidad de navegar por múltiples carpetas para revisarlos, lo que mejora la eficiencia en el desarrollo.</p></blockquote><ul><li><strong>Nombres de Archivos Más Intuitivos</strong>: Si la vista se llama <code>./views/Login/Index.vue</code>, su componente hijo puede llamarse directamente <code>Form.vue</code>. La nueva nomenclatura es más clara y directa.</li></ul><blockquote><p>En comparación con la estructura tradicional, donde se utilizarían nombres como <code>FormLogin.vue</code> o <code>LoginForm.vue</code> para diferenciarlo de otros formularios.</p></blockquote><ul><li><strong>Claridad en la Exclusividad</strong>: Los componentes y componibles anidados dentro del componente padre son de exclusividad del mismo, lo que facilita la comprensión de su propósito y uso.</li><li><strong>Reutilización Clara</strong>: Los componentes y componibles que no están anidados dentro de la carpeta del componente padre son reutilizables dentro de la jerarquía, lo que fomenta la modularidad y la reutilización del código.</li></ul><h2 id="contras" tabindex="-1">Contras <a class="header-anchor" href="#contras" aria-label="Permalink to &quot;Contras&quot;">​</a></h2><ul><li><strong>Necesidad de Refactorización</strong>: Es necesario estar pendiente de refactorizar la estructura según la jerarquía cada vez que se encuentre un componente hijo que pueda ser reutilizado por otro padre.</li></ul><blockquote><p>Cuando esto suceda, es necesario moverlo a una carpeta en algún lugar superior según la jerarquía. Lo mismo sucede con los componibles respectivamente.</p></blockquote><ul><li><strong>Posible Complejidad en Proyectos Grandes</strong>: A medida que el proyecto crece, la anidación de componentes y componibles puede llevar a una estructura más compleja, lo que podría dificultar la navegación y la comprensión de la jerarquía.</li></ul><blockquote><p>Sin embargo, cuando esto suceda, simplemente cierre todas las carpetas que no le interesen en ese momento y concéntrese solo en la carpeta en cuestión.</p></blockquote><ul><li><strong>Dependencia de la Estructura</strong>: La organización de los componentes y componibles hijos depende en gran medida de la estructura del los componentes y componibles padres.</li></ul><blockquote><p>Si se realizan cambios en la estructura de los componentes o componibles padres, puede ser necesario realizar ajustes en distintos lugares.</p></blockquote><h2 id="resumen" tabindex="-1">Resumen <a class="header-anchor" href="#resumen" aria-label="Permalink to &quot;Resumen&quot;">​</a></h2><p>Este enfoque propuesto para la organización de un proyecto <a href="https://vuejs.org/" target="_blank" rel="noreferrer">Vue.js</a> va más allá de la simple estructura modular, incorporando la anidación de componentes y componibles según su propósito. Esta metodología permite una agrupación lógica de archivos relacionados, facilitando la navegación y la comprensión del código.</p><blockquote><p>Al mantener los componentes y componibles secundarios dentro de sus respectivos componentes y componibles principales, se establece una exclusividad clara y se fomenta la reutilización de aquellos que son globales.</p></blockquote><p>Sin embargo, este enfoque también presenta desafíos, como la necesidad de refactorizar la estructura cuando se identifican componentes y componibles reutilizables más la posible complejidad en proyectos grandes. A pesar de estos contras, la capacidad de centrarse en un componente o componible específico y cerrar las carpetas no relevantes ayuda a mitigar la complejidad.</p><blockquote><p>En resumen, este enfoque modular y anidado proporciona una base sólida para el desarrollo de aplicaciones Vue.js, promoviendo la organización y la claridad en el código, mientras que también requiere una atención cuidadosa a la estructura a medida que el proyecto evoluciona.</p></blockquote>',21)]))}const b=a(s,[["render",l]]);export{m as __pageData,b as default};
